OK ‚Äî on va l‚Äôint√©grer sans casser ton code actuel et en gardant SuggestionEngine comme fa√ßade PVI.

L‚Äôid√©e la plus simple :

Tu cr√©es un moteur g√©n√©rique dans un package ‚Äúcommon‚Äù

Tu cr√©es, c√¥t√© PVI, un context + un resolver

Ta classe actuelle SuggestionEngine reste un @Service Spring, mais d√©l√®gue au moteur g√©n√©rique.

1) O√π mettre les classes
A. Module / package ‚Äúcommun‚Äù (r√©utilisable)

Dans ton module domain (ou un module commun si tu en as un), cr√©e :

com.bnpparibas.dsibddf.a100919.fis.domain.common.suggestion

GenericSuggestionEngine<C>

SuggestionContextResolver<C>

Ces classes ne d√©pendent d‚Äôaucun simulateur.

B. Module / package PVI (sp√©cifique)

Dans PVI, cr√©e :

com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine.suggestion

PviSuggestionContext

PviSuggestionResolver

Comme √ßa, PVI garde son m√©tier.

2) PviSuggestionContext : c‚Äôest quoi et o√π l‚Äôutiliser ?

C‚Äôest juste un objet ‚Äúporteur‚Äù qui regroupe les 2 objets que tu utilises d√©j√† dans resolveVariable :

package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine.suggestion;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.dto.PviSimulationRequest;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.result.PviSimulationResult;

public record PviSuggestionContext(
        PviSimulationRequest req,
        PviSimulationResult result
) {}


üëâ Il sera cr√©√© dans computeSuggestions(req, result) et envoy√© au moteur g√©n√©rique.

3) PviSuggestionResolver : comment le brancher

Il remplace ta m√©thode resolveVariable(...) actuelle.

package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine.suggestion;

import com.bnpparibas.dsibddf.a100919.fis.domain.common.suggestion.SuggestionContextResolver;

import java.math.BigDecimal;

public class PviSuggestionResolver implements SuggestionContextResolver<PviSuggestionContext> {

    @Override
    public Object resolve(String name, PviSuggestionContext ctx) {
        return switch (name) {
            case "grossCapitalGain"   -> ctx.result().getGrossCapitalGain();
            case "taxableCapitalGain" -> ctx.result().getTaxableCapitalGain();
            case "impots"             -> ctx.result().getTotalTaxes();
            case "holdingPeriodYears" -> BigDecimal.valueOf(ctx.result().getHoldingPeriodYears());

            case "propertyUse" -> ctx.req().propertyUse() == null ? null
                    : ctx.req().propertyUse().name().toLowerCase().replace('_', '-');

            case "propertyType" -> ctx.req().propertyType() == null ? null
                    : ctx.req().propertyType().name().toLowerCase();

            case "acquisitionOrigin" -> ctx.req().acquisitionOrigin() == null ? null
                    : ctx.req().acquisitionOrigin().name().toLowerCase();

            default -> null;
        };
    }
}


üëâ Celui-ci peut √™tre :

soit une classe simple instanci√©e (new PviSuggestionResolver())

soit un bean Spring @Component si tu veux l‚Äôinjecter (optionnel)

4) Adapter ta classe actuelle SuggestionEngine (sans changer l‚ÄôAPI)

Tu gardes exactement :

@Service

init()

computeSuggestions(PviSimulationRequest, PviSimulationResult) retourne List<SuggestionVO>

Mais au lieu d‚Äôavoir toute la logique dedans, tu d√©l√®gues.

‚úÖ Version d‚Äôadaptation minimaliste (recommand√©e)
package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine;

import com.bnpparibas.dsibddf.a100919.fis.domain.common.suggestion.GenericSuggestionEngine;
import com.bnpparibas.dsibddf.a100919.fis.domain.common.suggestion.SuggestionContextResolver;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.dto.PviSimulationRequest;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.result.PviSimulationResult;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.PviBusinessPropertiesVO;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.SuggestionVO;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine.suggestion.PviSuggestionContext;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine.suggestion.PviSuggestionResolver;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@RequiredArgsConstructor
public class SuggestionEngine {

    private final PviBusinessPropertiesVO pviBusinessProperties;

    @Setter
    private int maxSuggestions = 4;

    private final List<SuggestionVO> suggestionVOS = new ArrayList<>();

    // Le moteur g√©n√©rique (initialis√© apr√®s lecture YAML)
    private GenericSuggestionEngine<PviSuggestionContext> delegate;

    // Resolver m√©tier PVI
    private final SuggestionContextResolver<PviSuggestionContext> resolver = new PviSuggestionResolver();

    @PostConstruct
    public void init() {
        PviBusinessPropertiesVO.SuggestionProperties suggestionProps = pviBusinessProperties.getSuggestion();
        if (suggestionProps == null) return;

        if (suggestionProps.getShow() > 0) {
            this.maxSuggestions = suggestionProps.getShow();
        }

        Map<String, List<SuggestionVO>> suggestionsByCat = suggestionProps.getSuggestions();
        if (suggestionsByCat == null || suggestionsByCat.isEmpty()) return;

        // Flatten + normalisation cat√©gorie
        suggestionsByCat.forEach((categoryKey, list) -> {
            if (list == null) return;
            for (SuggestionVO s : list) {
                if (s.category() == null || s.category().isBlank()) {
                    suggestionVOS.add(new SuggestionVO(categoryKey, s.value(), s.condition()));
                } else {
                    suggestionVOS.add(s);
                }
            }
        });

        // ‚úÖ Initialisation du moteur g√©n√©rique avec les suggestions PVI
        this.delegate = new GenericSuggestionEngine<>(suggestionVOS, maxSuggestions, resolver);
    }

    public List<SuggestionVO> computeSuggestions(PviSimulationRequest req, PviSimulationResult result) {
        if (delegate == null) return List.of();

        PviSuggestionContext ctx = new PviSuggestionContext(req, result);
        return delegate.computeSuggestions(ctx);
    }
}


üëâ R√©sultat : ta classe reste inchang√©e pour les appelants, mais elle devient une fa√ßade.

5) Et pour un autre simulateur demain ?

Tu refais juste :

XxxSuggestionContext

XxxSuggestionResolver

XxxSuggestionEngine (fa√ßade) qui lit ses propres properties XxxBusinessPropertiesVO et d√©l√®gue au moteur g√©n√©rique.

6) Variante encore plus simple (si tu ne veux pas cr√©er de context)

Tu peux faire GenericSuggestionEngine sur un type Object[] ou sur un Map<String,Object> mais tu perds du typage. Le Context record est le meilleur compromis.

Si tu veux, envoie-moi :

la signature exacte de PviSimulationRequest (les enums)

la version exacte de SuggestionVO (avec url ou non)

et je te colle une version 100% compilable dans ton projet (imports + packages corrects).
