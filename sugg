package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.dto.PviSimulationRequest;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.result.PviSimulationResult;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.PviBusinessPropertiesVO;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.SuggestionVO;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.security.SecureRandom;
import java.util.*;

@Service
@RequiredArgsConstructor
public class SuggestionEngine {

    private final PviBusinessPropertiesVO pviBusinessProperties;

    @Setter
    private int maxSuggestions = 4;

    private final List<SuggestionVO> suggestionVOS = new ArrayList<>();

    private final SecureRandom random = new SecureRandom();

    // -------------------------------------------------------------------------
    // INITIALISATION
    // -------------------------------------------------------------------------
    @PostConstruct
    public void init() {
        PviBusinessPropertiesVO.SuggestionProperties suggestionProps = pviBusinessProperties.getSuggestion();
        if (suggestionProps == null) {
            return;
        }

        if (suggestionProps.getShow() > 0) {
            this.maxSuggestions = suggestionProps.getShow();
        }

        Map<String, List<SuggestionVO>> suggestionsByCategory = suggestionProps.getSuggestions();
        if (suggestionsByCategory == null || suggestionsByCategory.isEmpty()) {
            return;
        }

        suggestionsByCategory.forEach((categoryKey, list) -> {
            if (list == null) return;

            for (SuggestionVO s : list) {
                SuggestionVO normalized = s;
                if (s.category() == null || s.category().isBlank()) {
                    normalized = new SuggestionVO(categoryKey, s.value(), s.condition());
                }
                suggestionVOS.add(normalized);
            }
        });
    }

    // -------------------------------------------------------------------------
    // MÉTHODE PRINCIPALE : computeSuggestions (complexité réduite)
    // -------------------------------------------------------------------------
    public List<SuggestionVO> computeSuggestions(PviSimulationRequest req, PviSimulationResult result) {
        if (maxSuggestions <= 0 || suggestionVOS.isEmpty()) {
            return List.of();
        }

        Map<String, List<SuggestionVO>> eligibleByCategory =
                groupEligibleSuggestionsByCategory(req, result);

        if (eligibleByCategory.isEmpty()) {
            return List.of();
        }

        List<SuggestionVO> selected = new ArrayList<>();
        List<SuggestionVO> leftovers = new ArrayList<>();

        selectOnePerCategory(eligibleByCategory, selected, leftovers);
        fillFromLeftovers(selected, leftovers);

        return selected;
    }

    // -------------------------------------------------------------------------
    // EXTRACTIONS POUR BAISSER LA COMPLEXITÉ
    // -------------------------------------------------------------------------

    private Map<String, List<SuggestionVO>> groupEligibleSuggestionsByCategory(
            PviSimulationRequest req,
            PviSimulationResult result
    ) {
        Map<String, List<SuggestionVO>> eligibleByCategory = new LinkedHashMap<>();

        for (SuggestionVO s : suggestionVOS) {
            if (s.condition() == null || evalCondition(s.condition(), req, result)) {
                eligibleByCategory
                        .computeIfAbsent(s.category(), k -> new ArrayList<>())
                        .add(s);
            }
        }

        return eligibleByCategory;
    }

    private void selectOnePerCategory(
            Map<String, List<SuggestionVO>> eligibleByCategory,
            List<SuggestionVO> selected,
            List<SuggestionVO> leftovers
    ) {
        for (List<SuggestionVO> perCategory : eligibleByCategory.values()) {
            if (perCategory.isEmpty()) continue;

            int idx = random.nextInt(perCategory.size());
            SuggestionVO picked = perCategory.get(idx);
            selected.add(picked);

            for (int i = 0; i < perCategory.size(); i++) {
                if (i != idx) leftovers.add(perCategory.get(i));
            }
        }
    }

    private void fillFromLeftovers(List<SuggestionVO> selected, List<SuggestionVO> leftovers) {
        while (selected.size() < maxSuggestions && !leftovers.isEmpty()) {
            int idx = random.nextInt(leftovers.size());
            selected.add(leftovers.remove(idx));
        }
    }

    // -------------------------------------------------------------------------
    // MOTEUR DE CONDITIONS
    // -------------------------------------------------------------------------
    @SuppressWarnings("unchecked")
    private boolean evalCondition(Map<String, Object> node,
                                  PviSimulationRequest req,
                                  PviSimulationResult result) {

        if (node == null || node.isEmpty()) return true;

        Object part1Obj = node.get("part1");
        Object opObj    = node.get("operator");
        Object part2Obj = node.get("part2");

        if (part1Obj == null || opObj == null || part2Obj == null) {
            return true;
        }

        String op = String.valueOf(opObj);

        // Conditions composées (OR / AND)
        if (part1Obj instanceof Map<?, ?> leftMap
                && ((Map<?, ?>) leftMap).containsKey("part1")
                && ((Map<?, ?>) leftMap).containsKey("operator")) {

            Map<String, Object> leftCond  = (Map<String, Object>) leftMap;
            Map<String, Object> rightCond = (Map<String, Object>) part2Obj;

            boolean left  = evalCondition(leftCond, req, result);
            boolean right = evalCondition(rightCond, req, result);

            return switch (op) {
                case "||" -> left || right;
                case "&&" -> left && right;
                default   -> false;
            };
        }

        // Conditions simples
        String varName   = String.valueOf(part1Obj);
        Object leftValue = resolveVariable(varName, req, result);
        String rightRaw  = String.valueOf(part2Obj);

        return switch (op) {
            case "==" -> compareEquals(leftValue, rightRaw);
            case ">"  -> compareGreater(leftValue, rightRaw);
            case "<"  -> compareLess(leftValue, rightRaw);
            default   -> false;
        };
    }

    // -------------------------------------------------------------------------
    // RÉSOLUTIONS DE VARIABLES (mappage YAML → Java)
    // -------------------------------------------------------------------------
    private Object resolveVariable(String name,
                                   PviSimulationRequest req,
                                   PviSimulationResult result) {

        return switch (name) {
            case "grossCapitalGain"   -> result.getGrossCapitalGain();
            case "taxableCapitalGain" -> result.getTaxableCapitalGain();
            case "impots"             -> result.getTotalTaxes();
            case "holdingPeriodYears" -> BigDecimal.valueOf(result.getHoldingPeriodYears());

            case "propertyUse" -> req.propertyUse() == null
                    ? null
                    : req.propertyUse().name().toLowerCase().replace('_', '-');

            case "propertyType" -> req.propertyType() == null
                    ? null
                    : req.propertyType().name().toLowerCase();

            case "acquisitionOrigin" -> req.acquisitionOrigin() == null
                    ? null
                    : req.acquisitionOrigin().name().toLowerCase();

            default -> null;
        };
    }

    // -------------------------------------------------------------------------
    // COMPARAISONS
    // -------------------------------------------------------------------------
    private boolean compareEquals(Object left, String rightRaw) {
        if (left == null) return false;

        if (left instanceof BigDecimal bd) {
            try {
                BigDecimal right = new BigDecimal(rightRaw);
                return bd.compareTo(right) == 0;
            } catch (NumberFormatException e) {
                r
