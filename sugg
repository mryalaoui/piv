package com.bnpparibas.dsibddf.a100919.fis.domain.common.suggestion;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.SuggestionVO;

import java.security.SecureRandom;
import java.util.*;

public class GenericSuggestionEngine<C> {

    private final List<SuggestionVO> suggestions;
    private final int maxSuggestions;
    private final SuggestionContextResolver<C> resolver;
    private final SecureRandom random = new SecureRandom();

    public GenericSuggestionEngine(
            List<SuggestionVO> suggestions,
            int maxSuggestions,
            SuggestionContextResolver<C> resolver
    ) {
        this.suggestions = suggestions;
        this.maxSuggestions = maxSuggestions;
        this.resolver = resolver;
    }

    public List<SuggestionVO> computeSuggestions(C context) {
        if (maxSuggestions <= 0 || suggestions.isEmpty()) {
            return List.of();
        }

        Map<String, List<SuggestionVO>> eligibleByCategory = new LinkedHashMap<>();

        for (SuggestionVO s : suggestions) {
            if (s.condition() == null || evalCondition(s.condition(), context)) {
                eligibleByCategory
                        .computeIfAbsent(s.category(), k -> new ArrayList<>())
                        .add(s);
            }
        }

        return pickSuggestions(eligibleByCategory);
    }

    // ===================== PRIVATE =====================

    private List<SuggestionVO> pickSuggestions(Map<String, List<SuggestionVO>> eligibleByCategory) {
        List<SuggestionVO> selected = new ArrayList<>();
        List<SuggestionVO> leftovers = new ArrayList<>();

        for (List<SuggestionVO> perCategory : eligibleByCategory.values()) {
            if (perCategory.isEmpty()) continue;

            int idx = random.nextInt(perCategory.size());
            selected.add(perCategory.get(idx));

            for (int i = 0; i < perCategory.size(); i++) {
                if (i != idx) {
                    leftovers.add(perCategory.get(i));
                }
            }
        }

        while (selected.size() < maxSuggestions && !leftovers.isEmpty()) {
            selected.add(leftovers.remove(random.nextInt(leftovers.size())));
        }

        return selected;
    }

    @SuppressWarnings("unchecked")
    private boolean evalCondition(Map<String, Object> node, C context) {
        if (node == null || node.isEmpty()) return true;

        Object part1Obj = node.get("part1");
        Object opObj = node.get("operator");
        Object part2Obj = node.get("part2");

        if (part1Obj == null || opObj == null || part2Obj == null) return true;

        String op = String.valueOf(opObj);

        // Condition compos√©e
        if (part1Obj instanceof Map<?, ?> leftMap
                && leftMap.containsKey("part1")
                && leftMap.containsKey("operator")) {

            boolean left = evalCondition((Map<String, Object>) part1Obj, context);
            boolean right = evalCondition((Map<String, Object>) part2Obj, context);

            return "||".equals(op) ? left || right
                 : "&&".equals(op) && left && right;
        }

        Object leftValue = resolver.resolve(String.valueOf(part1Obj), context);
        String rightRaw = String.valueOf(part2Obj);

        return switch (op) {
            case "==" -> compareEquals(leftValue, rightRaw);
            case ">"  -> compareGreater(leftValue, rightRaw);
            case "<"  -> compareLess(leftValue, rightRaw);
            default   -> false;
        };
    }

    private boolean compareEquals(Object left, String rightRaw) {
        return left != null && left.toString().equalsIgnoreCase(rightRaw);
    }

    private boolean compareGreater(Object left, String rightRaw) {
        return left instanceof Number n
                && Double.parseDouble(rightRaw) < n.doubleValue();
    }

    private boolean compareLess(Object left, String rightRaw) {
        return left instanceof Number n
                && Double.parseDouble(rightRaw) > n.doubleValue();
    }
}
