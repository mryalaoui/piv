package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.dto.PviSimulationRequest;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.result.PviSimulationResult;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.SuggestionVO;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.math.BigDecimal;
import java.util.*;

/**
 * Moteur de suggestions PVI :
 * - charge le JSON /pvi/suggestion.json
 * - évalue les conditions
 * - sélectionne des suggestions "à la façon PHP" :
 *   1 par catégorie, puis complétion aléatoire jusqu'à maxSuggestions.
 */
@Service
@RequiredArgsConstructor
public class SuggestionEngine {

    public static final String PVI_SUGGESTION_JSON = "/pvi/suggestion.json";

    private final ObjectMapper objectMapper;

    // valeur par défaut, éventuellement surchargée par le JSON ("show")
    private int maxSuggestions = 4;

    // liste complète de toutes les suggestions chargées
    private final List<SuggestionVO> suggestionVOS = new ArrayList<>();

    @PostConstruct
    public void load() throws Exception {
        try (InputStream is = getClass().getResourceAsStream(PVI_SUGGESTION_JSON)) {
            JsonNode root = objectMapper.readTree(is);
            if (root.has("show")) {
                maxSuggestions = root.get("show").asInt(4);
            }

            JsonNode sugRoot = root.get("suggestions");
            if (sugRoot == null || !sugRoot.isObject()) {
                return;
            }

            Iterator<String> fieldNames = sugRoot.fieldNames();
            while (fieldNames.hasNext()) {
                String category = fieldNames.next();              // ex: "general", "fiscal", ...
                JsonNode array = sugRoot.get(category);
                if (array != null && array.isArray()) {
                    for (JsonNode sNode : array) {
                        String value = sNode.get("value").asText();
                        String url = sNode.hasNonNull("url") ? sNode.get("url").asText() : null;
                        JsonNode condition = sNode.get("condition");

                        suggestionVOS.add(new SuggestionVO(category, value, url, condition));
                    }
                }
            }
        }
    }

    /**
     * Permet, en test, de surcharger la limite (ex: 20)
     * pour balayer toutes les règles de gestion.
     */
    public void setMaxSuggestions(int maxSuggestions) {
        this.maxSuggestions = maxSuggestions;
    }

    public List<SuggestionVO> computeSuggestions(PviSimulationRequest req, PviSimulationResult result) {
        if (maxSuggestions <= 0) {
            return List.of();
        }

        // 1) Filtrer toutes les suggestions éligibles, regroupées par catégorie
        Map<String, List<SuggestionVO>> eligibleByCategory = new LinkedHashMap<>();

        for (SuggestionVO s : suggestionVOS) {
            if (s.conditionNode() == null || evalCondition(s.conditionNode(), req, result)) {
                eligibleByCategory
                        .computeIfAbsent(s.category(), k -> new ArrayList<>())
                        .add(s);
            }
        }

        List<SuggestionVO> selected = new ArrayList<>();
        List<SuggestionVO> leftovers = new ArrayList<>();
        Random random = new Random();

        // 2) Une suggestion aléatoire par catégorie (si disponible)
        for (List<SuggestionVO> perCategory : eligibleByCategory.values()) {
            if (perCategory.isEmpty()) {
                continue;
            }
            int idx = random.nextInt(perCategory.size());
            SuggestionVO picked = perCategory.get(idx);
            selected.add(picked);

            // les autres de la catégorie partent dans les "leftovers"
            for (int i = 0; i < perCategory.size(); i++) {
                if (i != idx) {
                    leftovers.add(perCategory.get(i));
                }
            }
        }

        // 3) Compléter aléatoirement jusqu'à maxSuggestions avec les leftovers
        while (selected.size() < maxSuggestions && !leftovers.isEmpty()) {
            int idx = random.nextInt(leftovers.size());
            selected.add(leftovers.remove(idx));
        }

        return selected;
    }

    // ---------------------- Évaluation de condition ----------------------

    private boolean evalCondition(JsonNode node, PviSimulationRequest req, PviSimulationResult result) {
        if (node == null || node.isNull()) {
            return true;
        }

        JsonNode part1 = node.get("part1");
        JsonNode opNode = node.get("operator");
        JsonNode part2 = node.get("part2");

        if (part1 == null || opNode == null || part2 == null) {
            // JSON mal formé ⇒ on considère la suggestion comme toujours éligible
            return true;
        }

        String op = opNode.asText();

        // Cas "composé" (OR / AND entre deux conditions)
        if (part1.isObject() && part1.has("part1") && part1.has("operator")) {
            boolean left = evalCondition(part1, req, result);
            boolean right = evalCondition(part2, req, result);
            return switch (op) {
                case "||" -> left || right;
                case "&&" -> left && right;
                default -> false;
            };
        }

        // Cas simple : var OP constante
        String varName = part1.asText();
        Object leftValue = resolveVariable(varName, req, result);

        String rightRaw = part2.asText();

        return switch (op) {
            case "==" -> compareEquals(leftValue, rightRaw);
            case ">"  -> compareGreater(leftValue, rightRaw);
            case "<"  -> compareLess(leftValue, rightRaw);
            default   -> false;
        };
    }

    private Object resolveVariable(String name, PviSimulationRequest req, PviSimulationResult result) {
        return switch (name) {
            case "plusValueBrute" -> result.getPlusValueBrute();
            case "plusValueNette" -> result.getPlusValueNette();
            case "impots"         -> result.getImpotsTotaux();
            case "detentionAnnee" -> BigDecimal.valueOf(result.getDetentionAnnee());

            case "usageBien" -> req.usageBien() == null
                    ? null
                    : req.usageBien().name().toLowerCase().replace('_', '-');

            case "typeBien" -> req.typeBien() == null
                    ? null
                    : req.typeBien().name().toLowerCase();

            case "origineBien" -> req.origineBien() == null
                    ? null
                    : req.origineBien().name().toLowerCase();

            default -> null;
        };
    }

    private boolean compareEquals(Object left, String rightRaw) {
        if (left == null) return false;

        if (left instanceof BigDecimal bd) {
            try {
                BigDecimal right = new BigDecimal(rightRaw);
                return bd.compareTo(right) == 0;
            } catch (NumberFormatException e) {
                return false;
            }
        }

        String leftStr = left.toString();
        return leftStr.equalsIgnoreCase(rightRaw);
    }

    private boolean compareGreater(Object left, String rightRaw) {
        if (!(left instanceof BigDecimal bd)) {
            return false;
        }
        try {
            BigDecimal right = new BigDecimal(rightRaw);
            return bd.compareTo(right) > 0;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private boolean compareLess(Object left, String rightRaw) {
        if (!(left instanceof BigDecimal bd)) {
            return false;
        }
        try {
            BigDecimal right = new BigDecimal(rightRaw);
            return bd.compareTo(right) < 0;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
