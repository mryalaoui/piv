package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.calculator;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.config.PviBusinessProperties;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.DeductionYearVO;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.TreeMap;

@Service
@RequiredArgsConstructor
public class DeductionCalculator {

    private final PviBusinessProperties pviBusinessProperties;

    /**
     * Map des abattements par année de détention.
     * On utilise un TreeMap pour pouvoir facilement récupérer
     * la première et la dernière clé (min / max).
     */
    private final Map<Integer, DeductionYearVO> abattementByYear = new TreeMap<>();

    /**
     * Expose une vue non modifiable de la configuration chargée.
     */
    public Map<Integer, DeductionYearVO> getAbattementByYear() {
        return Collections.unmodifiableMap(abattementByYear);
    }

    /**
     * Initialisation après injection :
     * on charge les abattements à partir de PviBusinessProperties (YAML).
     */
    @PostConstruct
    public void init() {
        Map<Integer, DeductionYearVO> fromConfig = pviBusinessProperties.getDeductionsByYear();

        abattementByYear.clear();

        if (fromConfig != null && !fromConfig.isEmpty()) {
            abattementByYear.putAll(fromConfig);
        }

        if (abattementByYear.isEmpty()) {
            // On choisit de "fail fast" : si la config est absente, c'est un vrai problème de paramétrage.
            throw new IllegalStateException("PVI deductionsByYear configuration is missing or empty.");
        }
    }

    /**
     * Retourne l'abattement applicable pour un nombre d'années de détention donné.
     * Si le nombre d'années est en dehors des bornes connues, on "clampe" :
     *   - en dessous de la première année → on prend la première
     *   - au-dessus de la dernière année → on prend la dernière
     */
    public DeductionYearVO getAbattementFor(int detentionYears) {
        if (abattementByYear.isEmpty()) {
            throw new IllegalStateException("Abattement configuration not initialized.");
        }

        TreeMap<Integer, DeductionYearVO> tree = (TreeMap<Integer, DeductionYearVO>) abattementByYear;

        int minYear = tree.firstKey();
        int maxYear = tree.lastKey();

        int key = Math.clamp(detentionYears, minYear, maxYear);

        return abattementByYear.get(key);
    }
}
