package com.bnpparibas.dsibddf.simulator.common.suggestion;

import java.math.BigDecimal;
import java.security.SecureRandom;
import java.util.*;

public class GenericSuggestionEngine<C> {

    private final List<SuggestionItem> suggestions;
    private final SuggestionContextResolver<C> resolver;
    private final int maxSuggestions;
    private final SecureRandom random = new SecureRandom();

    public GenericSuggestionEngine(List<SuggestionItem> suggestions,
                                   int maxSuggestions,
                                   SuggestionContextResolver<C> resolver) {
        this.suggestions = suggestions;
        this.maxSuggestions = maxSuggestions;
        this.resolver = resolver;
    }

    // ============================================================
    // ==================== PUBLIC API ============================
    // ============================================================
    public List<SuggestionItem> computeSuggestions(C context) {

        if (maxSuggestions <= 0 || suggestions.isEmpty()) {
            return List.of();
        }

        Map<String, List<SuggestionItem>> eligibleByCategory = filterEligible(context);

        List<SuggestionItem> selected = selectOnePerCategory(eligibleByCategory);

        completeWithLeftovers(eligibleByCategory, selected);

        return selected;
    }

    // ============================================================
    // ===================== FILTERING ============================
    // ============================================================
    private Map<String, List<SuggestionItem>> filterEligible(C context) {
        Map<String, List<SuggestionItem>> eligible = new LinkedHashMap<>();

        for (SuggestionItem s : suggestions) {
            if (s.condition() == null || evalCondition(s.condition(), context)) {
                eligible.computeIfAbsent(s.category(), k -> new ArrayList<>()).add(s);
            }
        }
        return eligible;
    }

    // ============================================================
    // ===================== SELECTION ============================
    // ============================================================
    private List<SuggestionItem> selectOnePerCategory(Map<String, List<SuggestionItem>> eligible) {
        List<SuggestionItem> selected = new ArrayList<>();

        for (List<SuggestionItem> list : eligible.values()) {
            if (!list.isEmpty()) {
                selected.add(list.get(random.nextInt(list.size())));
            }
        }
        return selected;
    }

    private void completeWithLeftovers(Map<String, List<SuggestionItem>> eligible,
                                       List<SuggestionItem> selected) {

        List<SuggestionItem> leftovers = new ArrayList<>();

        for (List<SuggestionItem> list : eligible.values()) {
            for (SuggestionItem s : list) {
                if (!selected.contains(s)) {
                    leftovers.add(s);
                }
            }
        }

        while (selected.size() < maxSuggestions && !leftovers.isEmpty()) {
            selected.add(leftovers.remove(random.nextInt(leftovers.size())));
        }
    }

    // ============================================================
    // =================== CONDITION ENGINE ======================
    // ============================================================
    @SuppressWarnings("unchecked")
    private boolean evalCondition(Map<String, Object> node, C context) {

        Object part1 = node.get("part1");
        Object operator = node.get("operator");
        Object part2 = node.get("part2");

        if (part1 == null || operator == null || part2 == null) {
            return true;
        }

        String op = operator.toString();

        // Condition compos√©e (OR / AND)
        if (part1 instanceof Map<?, ?> leftMap) {
            boolean left = evalCondition((Map<String, Object>) leftMap, context);
            boolean right = evalCondition((Map<String, Object>) part2, context);

            return "||".equals(op) ? left || right :
                   "&&".equals(op) ? left && right : false;
        }

        Object leftValue = resolver.resolve(part1.toString(), context);
        String rightValue = part2.toString();

        return switch (op) {
            case "==" -> compareEquals(leftValue, rightValue);
            case ">"  -> compareGreater(leftValue, rightValue);
            case "<"  -> compareLess(leftValue, rightValue);
            default   -> false;
        };
    }

    // ============================================================
    // ===================== COMPARATORS =========================
    // ============================================================
    private boolean compareEquals(Object left, String right) {
        if (left == null) return false;

        if (left instanceof BigDecimal bd) {
            return bd.compareTo(new BigDecimal(right)) == 0;
        }
        return left.toString().equalsIgnoreCase(right);
    }

    private boolean compareGreater(Object left, String right) {
        return left instanceof BigDecimal bd && bd.compareTo(new BigDecimal(right)) > 0;
    }

    private boolean compareLess(Object left, String right) {
        return left instanceof BigDecimal bd && bd.compareTo(new BigDecimal(right)) < 0;
    }
}
