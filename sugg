package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.calculator;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.config.PviBusinessProperties;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.CapitalGainTaxBracketVO;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CapitalGainTaxCalculator {

    /**
     * Configuration métier PVI (chargée depuis application.yml).
     */
    private final PviBusinessProperties pviBusinessProperties;

    /**
     * Liste interne des tranches, triée par min.
     */
    private final List<CapitalGainTaxBracketVO> brackets = new ArrayList<>();

    /**
     * Initialisation après injection : on récupère les tranches depuis
     * PviBusinessProperties et on les trie par borne minimale.
     */
    @PostConstruct
    public void init() {
        List<CapitalGainTaxBracketVO> fromConfig = pviBusinessProperties.getCapitalGainSurtaxBrackets();
        brackets.clear();
        if (fromConfig != null) {
            brackets.addAll(fromConfig);
            brackets.sort(Comparator.comparing(CapitalGainTaxBracketVO::min));
        }
    }

    /**
     * Calcule la surtaxe sur la plus-value imposable (plusValueIR).
     * Si plusValueIR est nulle, négative ou aucune tranche ne matche, retourne 0.
     */
    public BigDecimal computeCapitalGainSurtax(BigDecimal plusValueIR) {
        if (plusValueIR == null || plusValueIR.signum() <= 0) {
            return BigDecimal.ZERO;
        }
        if (brackets.isEmpty()) {
            // Config non présente / mal chargée : on préfère renvoyer 0 plutôt que planter.
            return BigDecimal.ZERO;
        }

        for (CapitalGainTaxBracketVO b : brackets) {
            boolean match;
            if (b.max() != null) {
                match = plusValueIR.compareTo(b.min()) >= 0
                        && plusValueIR.compareTo(b.max()) <= 0;
            } else {
                // Dernière tranche ouverte : min <= plusValueIR < +∞
                match = plusValueIR.compareTo(b.min()) >= 0;
            }

            if (match) {
                return computeBracketTax(b, plusValueIR);
            }
        }

        return BigDecimal.ZERO;
    }

    /**
     * Applique la formule de calcul de la surtaxe pour une tranche donnée :
     *   percentTerm  = (pourcentagePlusValue / 100) * plusValueIR
     *   rapportTerm  = (max - plusValueIR) * rapport   (si max et rapport non nuls)
     *   surtaxe      = (percentTerm - rapportTerm) arrondi à l'euro le plus proche.
     */
    private BigDecimal computeBracketTax(CapitalGainTaxBracketVO b, BigDecimal plusValueIR) {
        BigDecimal percentTerm = b.pourcentagePlusValue()
                .divide(new BigDecimal("100"))
                .multiply(plusValueIR);

        BigDecimal rapportTerm = BigDecimal.ZERO;
        if (b.max() != null && b.rapport() != null) {
            rapportTerm = b.max()
                    .subtract(plusValueIR)
                    .multiply(b.rapport());
        }

        return percentTerm
                .subtract(rapportTerm)
                .setScale(0, RoundingMode.HALF_UP);
    }
}
