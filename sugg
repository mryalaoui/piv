Étape 2 — DTO : on ajoute l’annotation de validation + quelques annotations simples

✅ On garde ton DTO tel quel, mais on ajoute :

@ValidPviRequest sur la classe (validation cross-field)

@Pattern pour les enums string (ou contrôle dans le validator)

@PositiveOrZero sur les BigDecimal (si tu veux “simple”)

package com.bnpparibas.dsibddf.a100919.fis.exposition.api.pvi.dto;

import com.bnpparibas.dsibddf.a100919.fis.exposition.api.pvi.validation.ValidPviRequest;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.Data;

import java.math.BigDecimal;

@Data
@ValidPviRequest // cross-field validation (dates, renovation logic, etc.)
@Schema(name = "PviSimulationRequest")
public class PviRequestDTO {

    @Schema(requiredMode = Schema.RequiredMode.REQUIRED, allowableValues = {"APARTMENT", "HOUSE", "LAND"})
    @NotBlank(message = "propertyType is required")
    @Pattern(regexp = "APARTMENT|HOUSE|LAND", message = "propertyType must be one of: APARTMENT, HOUSE, LAND")
    private String propertyType;

    @Schema(example = "SECONDARY_RESIDENCE")
    @Pattern(
            regexp = "^$|PRIMARY_RESIDENCE|SECONDARY_RESIDENCE|LOCATION",
            message = "propertyUse must be one of: PRIMARY_RESIDENCE, SECONDARY_RESIDENCE, LOCATION"
    )
    private String propertyUse;

    @Schema(example = "PURCHASE")
    @Pattern(
            regexp = "^$|PURCHASE|GIFT|INHERITANCE",
            message = "acquisitionOrigin must be one of: PURCHASE, GIFT, INHERITANCE"
    )
    private String acquisitionOrigin;

    @Schema(example = "2013-03-15", description = "Acquisition date (yyyy-MM-dd)")
    private String acquisitionDate;

    @Schema(example = "2025-09-10", description = "Sale date (yyyy-MM-dd)")
    private String saleDate;

    @Schema(example = "150000")
    @PositiveOrZero(message = "acquisitionPrice must be >= 0")
    private BigDecimal acquisitionPrice;

    @Schema(example = "0")
    @PositiveOrZero(message = "actualAcquisitionCosts must be >= 0")
    private BigDecimal actualAcquisitionCosts;

    @Schema(example = "280000")
    @PositiveOrZero(message = "salePrice must be >= 0")
    private BigDecimal salePrice;

    @Schema(example = "0")
    @PositiveOrZero(message = "saleCosts must be >= 0")
    private BigDecimal saleCosts;

    @Schema(example = "NO", allowableValues = {"YES", "NO"})
    @Pattern(regexp = "^$|YES|NO", message = "hasRenovation must be YES or NO")
    private String hasRenovation;

    @Schema(example = "0")
    @PositiveOrZero(message = "renovationAmount must be >= 0")
    private BigDecimal renovationAmount;
}


Si tu n’aimes pas les @Pattern, on peut tout mettre dans le validator. Mais là c’est simple et clair.

Étape 3 — ValidPviRequest (interface annotation)
package com.bnpparibas.dsibddf.a100919.fis.exposition.api.pvi.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = PviRequestValidator.class)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidPviRequest {

    String message() default "Invalid PVI request";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}

Étape 4 — Validator : PAS d’exception ici (important)

✅ Comme tu veux utiliser ExceptionTranslator standard, le plus propre est :

le validator n’émet pas de RuntimeException

il remplit le ConstraintValidatorContext avec les erreurs

Spring déclenche MethodArgumentNotValidException → déjà géré en 400 par ExceptionTranslator

package com.bnpparibas.dsibddf.a100919.fis.exposition.api.pvi.validation;

import com.bnpparibas.dsibddf.a100919.fis.exposition.api.pvi.dto.PviRequestDTO;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;

public class PviRequestValidator implements ConstraintValidator<ValidPviRequest, PviRequestDTO> {

    @Override
    public boolean isValid(PviRequestDTO dto, ConstraintValidatorContext ctx) {
        if (dto == null) return true;

        boolean ok = true;
        ctx.disableDefaultConstraintViolation();

        // Dates format + ordering
        LocalDate acquisition = parseDate(dto.getAcquisitionDate(), "acquisitionDate", ctx);
        LocalDate sale = parseDate(dto.getSaleDate(), "saleDate", ctx);

        if (acquisition != null && sale != null && sale.isBefore(acquisition)) {
            ok = false;
            addViolation(ctx, "saleDate", "saleDate must be after or equal to acquisitionDate");
        }

        // Renovation logic
        String hasRenovation = trimToNull(dto.getHasRenovation());
        BigDecimal renovationAmount = dto.getRenovationAmount();

        if ("YES".equalsIgnoreCase(hasRenovation)) {
            if (renovationAmount == null || renovationAmount.signum() <= 0) {
                ok = false;
                addViolation(ctx, "renovationAmount", "renovationAmount must be > 0 when hasRenovation = YES");
            }
        }

        return ok;
    }

    private LocalDate parseDate(String raw, String field, ConstraintValidatorContext ctx) {
        String v = trimToNull(raw);
        if (v == null) return null;
        try {
            return LocalDate.parse(v); // expects yyyy-MM-dd
        } catch (DateTimeParseException e) {
            addViolation(ctx, field, field + " must respect format yyyy-MM-dd");
            return null;
        }
    }

    private void addViolation(ConstraintValidatorContext ctx, String field, String message) {
        ctx.buildConstraintViolationWithTemplate(message)
                .addPropertyNode(field)
                .addConstraintViolation();
    }

    private String trimToNull(String s) {
        if (s == null) return null;
        String t = s.trim();
        return t.isEmpty() ? null : t;
    }
}

Étape 5 — ExceptionTranslator : on garde le handler global, mais on évite qu’il masque

Tu as déjà :

MethodArgumentNotValidException → 400 ✅

HttpMessageNotReadableException → 400 ✅

✅ Donc pour la validation ci-dessus, tu n’as rien à changer.

Mais si tu veux identifier PVI dans les erreurs (sans créer un autre advice), tu peux juste mettre un code plus précis dans les handlers existants quand la requête est PVI (optionnel).

Étape 6 — Pourquoi tu avais 500 avant ?

Parce que tu avais @ExceptionHandler(Exception.class) qui catchait tout et renvoyait 500.
Normalement Spring choisit le handler le plus spécifique, mais dès que tu as plusieurs @ControllerAdvice / ordres / résolutions, tu peux te retrouver avec le catch-all qui prend la main.

✅ Si tu veux le garder : ajoute @Order(LOWEST_PRECEDENCE) sur ce ExceptionTranslator, ou mets le handler Exception.class dans une autre classe @ControllerAdvice dédiée avec @Order(LOWEST_PRECEDENCE).

Ce que je te propose comme “première vérification” (comme tu voulais)

Première chose à vérifier :
➡️ Ton ExceptionTranslator.handleMethodArgumentNotValid est bien appelé quand une validation échoue.

Test rapide :

envoie propertyType: "" → doit retourner 400 avec message propertyType: propertyType is required

Si ça marche, alors :
➡️ on passe à la validation cross-field @ValidPviRequest (dates + renovation).

Si tu me dis les valeurs exactes attendues pour propertyUse et acquisitionOrigin (la liste exacte des enums du domain), je te mets les regex exactes / ou je te bascule ces champs en enum côté API (ce qui est encore plus propre).

Chat vocal terminé
5s

ChatGPT peut com
