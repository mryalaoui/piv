package com.bnpparibas.dsibddf.a100919.fis.domain.pvi.service.engine;

import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.config.PviBusinessProperties;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.dto.PviSimulationRequest;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.result.PviSimulationResult;
import com.bnpparibas.dsibddf.a100919.fis.domain.pvi.model.vo.SuggestionVO;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.security.SecureRandom;
import java.util.*;

@Service
@RequiredArgsConstructor
public class SuggestionEngine {

    private final PviBusinessProperties pviBusinessProperties;

    @Setter
    private int maxSuggestions = 4;

    /**
     * Liste complète de toutes les suggestions chargées à partir de la config YAML.
     */
    private final List<SuggestionVO> suggestionVOS = new ArrayList<>();

    private final SecureRandom random = new SecureRandom();

    @PostConstruct
    public void init() {
        PviBusinessProperties.SuggestionProperties suggestionProps = pviBusinessProperties.getSuggestion();
        if (suggestionProps == null) {
            // Pas de bloc suggestion => aucune suggestion
            return;
        }

        // show = nombre max de suggestions à afficher
        if (suggestionProps.getShow() > 0) {
            this.maxSuggestions = suggestionProps.getShow();
        }

        Map<String, List<SuggestionVO>> suggestionsByCategory = suggestionProps.getSuggestions();
        if (suggestionsByCategory == null || suggestionsByCategory.isEmpty()) {
            return;
        }

        // Aplatir la Map<String, List<SuggestionVO>> en une seule liste,
        // en s’assurant que la catégorie est bien renseignée dans le VO.
        suggestionsByCategory.forEach((categoryKey, list) -> {
            if (list == null) {
                return;
            }
            for (SuggestionVO s : list) {
                SuggestionVO normalized = s;
                if (s.category() == null || s.category().isBlank()) {
                    normalized = new SuggestionVO(categoryKey, s.value(), s.url(), s.condition());
                }
                suggestionVOS.add(normalized);
            }
        });
    }

    public List<SuggestionVO> computeSuggestions(PviSimulationRequest req, PviSimulationResult result) {
        if (maxSuggestions <= 0 || suggestionVOS.isEmpty()) {
            return List.of();
        }

        Map<String, List<SuggestionVO>> eligibleByCategory = new LinkedHashMap<>();

        for (SuggestionVO s : suggestionVOS) {
            if (s.condition() == null || evalCondition(s.condition(), req, result)) {
                eligibleByCategory
                        .computeIfAbsent(s.category(), k -> new ArrayList<>())
                        .add(s);
            }
        }

        List<SuggestionVO> selected = new ArrayList<>();
        List<SuggestionVO> leftovers = new ArrayList<>();

        // 1) On prend au maximum 1 suggestion par catégorie (tirage aléatoire),
        //    les autres vont dans "leftovers"
        for (List<SuggestionVO> perCategory : eligibleByCategory.values()) {
            if (perCategory.isEmpty()) {
                continue;
            }
            int idx = random.nextInt(perCategory.size());
            SuggestionVO picked = perCategory.get(idx);
            selected.add(picked);

            for (int i = 0; i < perCategory.size(); i++) {
                if (i != idx) {
                    leftovers.add(perCategory.get(i));
                }
            }
        }

        // 2) On complète avec des suggestions restantes jusqu'à maxSuggestions
        while (selected.size() < maxSuggestions && !leftovers.isEmpty()) {
            int idx = random.nextInt(leftovers.size());
            selected.add(leftovers.remove(idx));
        }

        return selected;
    }

    /**
     * Évalue récursivement une condition représentée par une Map<String, Object>,
     * construite à partir du YAML. On supporte :
     * - conditions simples : { part1: "grossCapitalGain", operator: ">", part2: "0" }
     * - conditions composées : { part1: { ... }, operator: "||", part2: { ... } }
     */
    @SuppressWarnings("unchecked")
    private boolean evalCondition(Map<String, Object> node, PviSimulationRequest req, PviSimulationResult result) {
        if (node == null || node.isEmpty()) {
            return true;
        }

        Object part1Obj = node.get("part1");
        Object opObj    = node.get("operator");
        Object part2Obj = node.get("part2");

        if (part1Obj == null || opObj == null || part2Obj == null) {
            // Condition mal formée → on la considère comme "true" pour ne pas bloquer l'affichage.
            return true;
        }

        String op = String.valueOf(opObj);

        // Cas condition composée (OR / AND) :
        // part1 et / ou part2 sont eux-mêmes des conditions (Map avec part1 / operator)
        if (part1Obj instanceof Map<?, ?> leftMap
                && ((Map<?, ?>) leftMap).containsKey("part1")
                && ((Map<?, ?>) leftMap).containsKey("operator")) {

            Map<String, Object> leftCond  = (Map<String, Object>) leftMap;
            Map<String, Object> rightCond = (Map<String, Object>) part2Obj;

            boolean left  = evalCondition(leftCond, req, result);
            boolean right = evalCondition(rightCond, req, result);

            return switch (op) {
                case "||" -> left || right;
                case "&&" -> left && right;
                default -> false;
            };
        }

        // Cas condition simple
        String varName  = String.valueOf(part1Obj);
        Object leftValue = resolveVariable(varName, req, result);
        String rightRaw  = String.valueOf(part2Obj);

        return switch (op) {
            case "==" -> compareEquals(leftValue, rightRaw);
            case ">"  -> compareGreater(leftValue, rightRaw);
            case "<"  -> compareLess(leftValue, rightRaw);
            default   -> false;
        };
    }

    private Object resolveVariable(String name, PviSimulationRequest req, PviSimulationResult result) {
        return switch (name) {
            case "grossCapitalGain"   -> result.getGrossCapitalGain();
            case "taxableCapitalGain" -> result.getTaxableCapitalGain();
            case "impots"             -> result.getTotalTaxes();
            case "holdingPeriodYears" -> BigDecimal.valueOf(result.getHoldingPeriodYears());

            case "propertyUse" -> req.propertyUse() == null
                    ? null
                    : req.propertyUse().name().toLowerCase().replace('_', '-');

            case "propertyType" -> req.propertyType() == null
                    ? null
                    : req.propertyType().name().toLowerCase();

            case "acquisitionOrigin" -> req.acquisitionOrigin() == null
                    ? null
                    : req.acquisitionOrigin().name().toLowerCase();

            default -> null;
        };
    }

    private boolean compareEquals(Object left, String rightRaw) {
        if (left == null) return false;

        if (left instanceof BigDecimal bd) {
            try {
                BigDecimal right = new BigDecimal(rightRaw);
                return bd.compareTo(right) == 0;
            } catch (NumberFormatException e) {
                return false;
            }
        }

        String leftStr = left.toString();
        return leftStr.equalsIgnoreCase(rightRaw);
    }

    private boolean compareGreater(Object left, String rightRaw) {
        if (!(left instanceof BigDecimal bd)) {
            return false;
        }
        try {
            BigDecimal right = new BigDecimal(rightRaw);
            return bd.compareTo(right) > 0;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private boolean compareLess(Object left, String rightRaw) {
        if (!(left instanceof BigDecimal bd)) {
            return false;
        }
        try {
            BigDecimal right = new BigDecimal(rightRaw);
            return bd.compareTo(right) < 0;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
